#created on: Aug 31, 2009
package edu.ucsc.eis.mario

#list any import classes here.
import edu.ucsc.eis.mario.sprites.Mario
import edu.ucsc.eis.mario.events.* 
import java.util.ArrayList
import java.util.Iterator
import function org.mockito.Mockito.*; 


#declare any global variables here

declare Jump
    @role(event)
    @expires(5s)
end

declare Landing
    @role(event)
    @expires(1s)
end

# Test rules to make sure facts are inserted
rule "jumpEventFound"
    ruleflow-group "Test"
    when
        $jump : Jump()
    then
        System.err.println("Found a jump event: " + $jump);
end

rule "Find landing event"
    ruleflow-group "Test"
    when
        $landing : Landing()
    then
        System.err.println("Found a landing event: " + $landing);
end

# Test interaction
rule "marioIsDucking"
    ruleflow-group "Test"
    when
        $mario : Mario()
        eval($mario.isDucking())
    then 
        System.err.println("Mario is ducking!");
end

# Book-keeping rules to ensure working agenda is valid from tick-to-tick
rule "Retract all jumps when a landing is found"
    ruleflow-group "Bookkeeping"
    when
        $landing : Landing()
        $jumps : ArrayList(size > 0) from collect(Jump())
    then
        for (Object jump : $jumps) {
            retract(jump);
        }
        
        retract($landing);
end

rule "Retract all landings"
    ruleflow-group "Bookkeeping"
    salience -1
    when
        $landing : Landing()
    then
        retract($landing);
end

# Integrity rules
rule "Stop Mario moving when he dies"
    ruleflow-group "Integrity"
    when
        $mario : Mario(deathTime == 1)
    then
        $mario.xa = 0;
        $mario.ya = 0;
end        

rule "stopMarioInteractionWhenDead"
    ruleflow-group "Integrity"
    when
        $mario : Mario(deathTime > 0)
    then
        $mario.keys = new boolean[16];
        System.err.println("Mario is dead");
end

/**
* This one will only work if a new fact is inserted, as updating Mario
* results in an implicit retraction and insertion, killing the activation
* for this rule. An immutable object (only need one, so the inserting rule
* should check for not(deathEvent())) could be inserted into the memory on the
* rules side instead, and the duration calculated on that.
*/
//rule "End level if Mario dies"
//    duration(1s)
//    when
//        $mario : Mario(deathTime > 0)
//    then
//        System.err.println("Mario should be dead now");
//end

/**
* This is a hard and fast parameter bug, but won't catch
* bugs that are caused by some other issue. For that, we'll
* need complex event processing, which is the next rule
*/

rule "marioTooHigh"
    ruleflow-group "Integrity"
    when
        $mario : Mario(jumpTime > 8)
    then
        System.err.println("Mario jumped too high");
        $mario.setJumpTime(-1);
        $mario.setYJumpSpeed(0);
end

//The window of time Mario jumped is too long
rule "marioJumpTooLong"
    ruleflow-group "Integrity"
    duration(2s)
    when
        $jump : Jump($mario : mario)
        not(Landing(this after[0s,2s] $jump))
    then
        System.err.println("Mario jumped too long");
        $mario.setJumpTime(-1);
        // 100 will bring Mario down *hard*
        $mario.setYJumpSpeed(100);
end

rule "Find a level with a pit"
    ruleflow-group "Integrity"
    when
        Mario($pitLength : world.level.largestPitLength > 0)
    then
        System.out.println("Level has a pit of length: " + $pitLength);
end

/** 
* TODO: Find out how pit length is set to 2: pits aren't ever larger than 2.
* Is it buildJump() in the LevelGenerator?
* - Intelligent operation is to work out how fast Mario can go before he jumps,
* then predict how far he can jump. This is a bit overkill, so we'll just
* detect jumps longer >= 4 blocks when there aren't any of those gray
* building blocks surrounding, or >= 2 when there are.
* The resolution of this will be to splice in a block on the end.
* - This evaluation shouldn't happen as a reference follow from the Mario fact,
* it should be it's own fact inserted into the rule engine (which could be a
* rule, using a not(LevelScene()) to make sure we only insert once).
*/  
   